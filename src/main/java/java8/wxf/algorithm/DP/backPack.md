#背包问题：
##一、背包分类
####1、按类型分
* 0-1背包：装入背包的每种可选类型只有一个
* 多重背包：装入背包的每种可选类型有多个
* 完全背包：装入背包的每种可选类型有无限个
####2、按问题分
* 可行性背包：在target大小的背包中可装入的最大值
* 最值型背包：装满target大小的背包有多少种方式
##二、背包解题思路
####（一）关键步骤：
  1、将 “前i件物品放入背包中可装入的最大值”或者“前i件物品能否拼出大小为j的容量”作为子问题。
 
  2、将背包容量大小放入数组中参与计算
  
  3、定义数组大小为 行：A.length+1,列：target+1，行列内容相反则含义不同注意区别
  
  4、枚举从0到背包大小target
  
  原因：背包容量只有target大小，取值范围只能在[0,target]
####（二）状态转移方程：

* 0-1背包：f[i][j] = Max(f[i-1][j], f[i-1][j-A[i-1]]+A[i-1])

  f[i][j]表示前i个物品能装入j大小的背包的最大值
  
  f[i-1][j]表示前i-1个物品能装入j大小的背包的最大值
  
  f[i-1][j-A[i-1]]+A[i-1]表示前i-1个物品加上最后一个物品能装入j大小的背包的最大值
  
* 多重背包：f[i][j] = Max(f[i-1][j], f[i-1][j-k*A[i-1]]+k*A[i-1]){k=1,2...nums[i-1]&&j-k*A[i-1]>=0}
* 完全背包：f[i][j] = Max(f[i-1][j], f[i-1][j-k*A[i-1]]+k*A[i-1]){k=1,2...target/A[i-1]&&j-k*A[i-1]>=0}

  k为物品数量，nums存的是对应的物品数量
##三、背包优化空间复杂度
####空间均可优化为一维数组，空间复杂度降为O(n);
#### 技巧：依据定义正序或者逆序遍历背包大小j,保证后者数据将不会覆盖前者。
* 0-1背包：
  
  dp[j] = max(dp[j], dp[j−w[i]]+v[i])
  
* 多重背包：
  
  dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
  
* 完全背包：

  dp[j] = max(dp[j], dp[j−w[i]]+v[i])