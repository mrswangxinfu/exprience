                           
#排序算法

### 折半查找
* 算法思路：
    * 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。
* 折半查找分析
    * 折半查找判定树
        * 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数
        * 时间复杂度为O(logn)
        * 概要: 具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。

### 分块查找
* 分块查找又称为索引顺序查找
* 分块查找思想：
    * ①确定待查找值在哪个块（折半查找）

②在确定的块中查找待查找值（顺序查找）
* 分块查找分析
    * 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。
即ASL分块=ASL折半+ASL顺序

                   
##1、冒泡排序：最坏时间复杂度O(n2)

   冒泡排序，是通过每一次遍历获取最大/最小值，
   
   将最大值/最小值放在尾部/头部，然后除开最大值/最小值，
   
   剩下的数据在进行遍历获取最大/最小值

   即：不断比较相邻的数据，将最大/最小值冒出来。
      
      public static void main(String[] args) {
      
              int arr[] = {8, 5, 3, 2, 4};
      
              //冒泡
              for (int i = 0; i < arr.length; i++) {
                  //外层循环，遍历次数
                  for (int j = 0; j < arr.length - i - 1; j++) {
                      //内层循环，升序（如果前一个值比后一个值大，则交换）
                      //内层循环一次，获取一个最大值
                      if (arr[j] > arr[j + 1]) {
                          int temp = arr[j + 1];
                          arr[j + 1] = arr[j];
                          arr[j] = temp;
                      }
                  }
              }
          }

##2、选择排序： 最坏时间复杂度O(n2)

   a、将第一个值看成最小值
   
   b、然后和后续的比较找出最小值和下标
   
   c、交换本次遍历的起始值和最小值
   
   d、说明：每次遍历的时候，将前面找出的最小值，看成一个有序的列表，
     
   后面的看成无序的列表，然后每次遍历无序列表找出最小值。
   
   即：每次都从剩下未排序的列表中寻找最大/最小值从头部或者尾部顺序放入直到排序结束。
      
      public static void main(String[] args) {
      
              int arr[] = {6, 5, 3, 2, 4};
      
              //选择
              for (int i = 0; i < arr.length; i++) {
                  //默认第一个是最小的。
                  int min = arr[i];
                  //记录最小的下标
                  int index = i;
                  //通过与后面的数据进行比较得出，最小值和下标
                  for (int j = i + 1; j < arr.length; j++) {
                      if (min > arr[j]) {
                          min = arr[j];
                          index = j;
                      }
                  }
                  //然后将最小值与本次循环的，开始值交换
                  int temp = arr[i];
                  arr[i] = min;
                  arr[index] = temp;
                  //说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。每次只需要找无需的最小值，做替换
              }
          }
   
##3、插入排序： 最坏时间复杂度O(n2)

   a、默认从第二个数据开始比较。
   
   b、如果第二个数据比第一个小，则交换。然后在用第三个数据比较，如果比前面小，则插入（狡猾）。否则，退出循环
   
   c、说明：默认将第一数据看成有序列表，后面无序的列表循环每一个数据，如果比前面的数据小则插入（交换）。否则退出。
   
   即：从第二个数据开始，比较前面的数据若小于/大于前面的数据则将数据插在前面数据之前。
      
      public static void main(String[] args) {
      
              int arr[] = {7, 5, 3, 2, 4};
      
              //插入排序
              for (int i = 1; i < arr.length; i++) {
                  //外层循环，从第二个开始比较
                  for (int j = i; j > 0; j--) {
                      //内存循环，与前面排好序的数据比较，如果后面的数据小于前面的则交换
                      if (arr[j] < arr[j - 1]) {
                          int temp = arr[j - 1];
                          arr[j - 1] = arr[j];
                          arr[j] = temp;
                      } else {
                          //如果不小于，说明插入完毕，退出内层循环
                          break;
                      }
                  }
              }
          }


##4、希尔排序：
  
   a、基本上和插入排序一样的道理
   
   b、不一样的地方在于，每次循环的步长，通过减半的方式来实现
   
   c、说明：基本原理和插入排序类似，不一样的地方在于。通过间隔多个数据来进行插入排序。
   
   即：相互间隔多个数据的两个数据进行比较交换。
   
       public static void main(String[] args) {
       
               int arr[] = {7, 5, 3, 2, 4};
       
               //希尔排序（插入排序变种版）
               for (int i = arr.length / 2; i > 0; i /= 2) {
                   //i层循环控制步长
                   for (int j = i; j < arr.length; j++) {
                       //j控制无序端的起始位置
                       for (int k = j; k > 0  && k - i >= 0; k -= i) {
                           if (arr[k] < arr[k - i]) {
                               int temp = arr[k - i];
                               arr[k - i] = arr[k];
                               arr[k] = temp;
                           } else {
                               break;
                           }
                       }
                   }
                   //j,k为插入排序，不过步长为i
               }
           }
           
          
##5、快速排序：

   同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。
   
   不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，
   
   而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，
   
   从而把数列拆解成了两个部分。
   
   也可以说从数列中挑出一个元素，称为 “基准”（pivot）；
   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

####------------------------------------------------------------------------------------------------------------------------------

   a、确认列表第一个数据为中间值，第一个值看成空缺（低指针空缺）。
   
   b、然后在剩下的队列中，看成有左右两个指针（高低）。
   
   c、开始高指针向左移动，如果遇到小于中间值的数据，则将这个数据赋值到低指针空缺，并且将高指针的数据看成空缺值（高指针空缺）。然后先向右移动一下低指针，并且切换低指针移动。
   
   d、当低指针移动到大于中间值的时候，赋值到高指针空缺的地方。然后先高指针向左移动，并且切换高指针移动。重复c、d操作。
   
   e、直到高指针和低指针相等时退出，并且将中间值赋值给对应指针位置。
   
   f、然后将中间值的左右两边看成行的列表，进行快速排序操作。
   
   主要思想是：分治法
   
   实现方式：
   
   * 随机选一个数据作为基准数据然后使用挖坑法或者指针交换法
        
        
      public static void main(String[] args) {
      
              int arr[] = {7, 5, 3, 2, 4, 1, 8, 9, 6};
      
              //快速排序
              int low = 0;
              int high = arr.length - 1;
              quickSort(arr, low, high);  
          }
      
          public static void quickSort(int[] arr, int low, int high) {
              //如果指针在同一位置(只有一个数据时)，退出
              if (high - low < 1) {
                  return;
              }
              //标记，从高指针开始，还是低指针（默认高指针）
              boolean flag = true;
              //记录指针的其实位置
              int start = low;
              int end = high;
              //默认中间值为低指针的第一个值
              int midValue = arr[low];
              while (true) {
                  //高指针移动
                  if (flag) {
                      //如果列表右方的数据大于中间值，则向左移动
                      if (arr[high] > midValue) {
                          high--;
                      } else if (arr[high] < midValue) {
                          //如果小于，则覆盖最开始的低指针值，并且移动低指针，标志位改成从低指针开始移动
                          arr[low] = arr[high];
                          low++;
                          flag = false;
                      }
                  } else {
                      //如果低指针数据小于中间值，则低指针向右移动
                      if (arr[low] < midValue) {
                          low++;
                      } else if (arr[low] > midValue) {
                          //如果低指针的值大于中间值，则覆盖高指针停留时的数据，并向左移动高指针。切换为高指针移动
                          arr[high] = arr[low];
                          high--;
                          flag = true;
                      }
                  }
                  //当两个指针的位置相同时，则找到了中间值的位置，并退出循环
                  if (low == high) {
                      arr[low] = midValue;
                      break;
                  }
              }
              //然后出现有，中间值左边的小于中间值。右边的大于中间值。
              //然后在对左右两边的列表在进行快速排序
              quickSort(arr, start, low -1);
              quickSort(arr, low + 1, end);
          }
          
##6、归并排序：

   a、将列表按照对等的方式进行拆分
   
   b、拆分小最小快的时候，在将最小块按照原来的拆分，进行合并
   
   c、合并的时候，通过左右两块的左边开始比较大小。小的数据放入新的块中
   
   d、说明：简单一点就是先对半拆成最小单位，然后将两半数据合并成一个有序的列表。
   
   即：通过二分法将一块数据作为母块分到不可再分的子块，再递归比较排序两个子块到母块中（归并到母块）。
   
   
      public static void main(String[] args) {
      
              int arr[] = {7, 5, 3, 2, 4, 1，6};
      
              //归并排序
              int start = 0;
              int end = arr.length - 1;
              mergeSort(arr, start, end);
          }
      
          public static void mergeSort(int[] arr, int start, int end) {
              //判断拆分的不为最小单位
              if (end - start > 0) {
                  //再一次拆分，知道拆成一个一个的数据
                  mergeSort(arr, start, (start + end) / 2);
                  mergeSort(arr, (start + end) / 2 + 1, end);
                  //记录开始/结束位置
                  int left = start;
                  int right = (start + end) / 2 + 1;
                  //记录每个小单位的排序结果
                  int index = 0;
                  int[] result = new int[end - start + 1];
                  //如果查分后的两块数据，都还存在
                  while (left <= (start + end) / 2 && right <= end) {
                      //比较两块数据的大小，然后赋值，并且移动下标
                      if (arr[left] <= arr[right]) {
                          result[index] = arr[left];
                          left++;
                      } else {
                          result[index] = arr[right];
                          right++;
                      }
                      //移动单位记录的下标
                      index++;
                  }
                  //当某一块数据不存在了时
                  while (left <= (start + end) / 2 || right <= end) {
                      //直接赋值到记录下标
                      if (left <= (start + end) / 2) {
                          result[index] = arr[left];
                          left++;
                      } else {
                          result[index] = arr[right];
                          right++;
                      }
                      index++;
                  }
                  //最后将新的数据赋值给原来的列表，并且是对应分块后的下标。
                  for (int i = start; i <= end; i++) {
                      arr[i] = result[i - start];
                  }
              }
          }
          
          
          
##7、堆排序
  * 堆：堆是一种非线性结构，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组
      按照堆的特点可以把堆分为大顶堆和小顶堆。
     * 大顶堆：每个结点的值都大于或等于其左右孩子结点的值
     * 小顶堆：每个结点的值都小于或等于其左右孩子结点的值
     
  * 堆排序（Heapsort） 是指利用堆这种数据结构所设计的一种排序算法。
    堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

7.1 算法描述
  
  * 步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
  * 步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
  * 步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
                                                                                    
    
  * 代码实现
     
     注意：这里用到了完全二叉树的部分性质：详情见数据结构二叉树知识点
     
     
     //声明全局变量，用于记录数组array的长度；
         static int len;
         /**
          * 堆排序算法
          *
          * @param array
          * @return
          */
         public static int[] HeapSort(int[] array) {
             len = array.length;
             if (len < 1) return array;
             //1.构建一个最大堆
             buildMaxHeap(array);
             //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆
             while (len > 0) {
                 swap(array, 0, len - 1);
                 len--;
                 adjustHeap(array, 0);
             }
             return array;
         }
         /**
          * 建立最大堆
          *
          * @param array
          */
         public static void buildMaxHeap(int[] array) {
             //从最后一个非叶子节点开始向上构造最大堆
             //for循环这样写会更好一点：i的左子树和右子树分别2i+1和2(i+1)
             for (int i = (len/2- 1); i >= 0; i--) {
                 adjustHeap(array, i);
             }
         }
         /**
          * 调整使之成为最大堆
          *
          * @param array
          * @param i
          */
         public static void adjustHeap(int[] array, int i) {
             int maxIndex = i;
             //如果有左子树，且左子树大于父节点，则将最大指针指向左子树
             if (i * 2 < len && array[i * 2] > array[maxIndex])
                 maxIndex = i * 2 + 1;
             //如果有右子树，且右子树大于父节点，则将最大指针指向右子树
             if (i * 2 + 1 < len && array[i * 2 + 1] > array[maxIndex])
                 maxIndex = i * 2 + 2; 
             //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
             if (maxIndex != i) {
                 swap(array, maxIndex, i);
                 adjustHeap(array, maxIndex);
             }
         }
         public static void swap(int[] arr, int i, int j) {
             int p = arr[i];
             arr[i] = arr[j];
             arr[j] = p;
         }
         
         
  算法分析
     
   * 最佳情况：T(n) = O(nlogn)
   * 最差情况：T(n) = O(nlogn)
   * 平均情况：T(n) = O(nlogn)

##8、计数排序
   * 计数排序 的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
   * 计数排序(Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。
  
  8.1 算法描述
  * 步骤1：找出待排序的数组中最大和最小的元素；
  * 步骤2：统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
  * 步骤3：对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
  * 步骤4：反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
  * 即：寻找最大最小值从而确定额外开辟数组的大小，额外数组的下标对应待排序数组的值，额外数组的
  值对应待排序数组值的个数。先将待排序数组根据其值按照额外数组的下标填入额外数组，填充结束后再
  将额外数组按照顺序使用值作为个数，将下标回填到待排序数组中。
  
  
 
    /**
       * 计数排序
       *
       * @param array
       * @return
       */
      public static int[] CountingSort(int[] array) {
          if (array.length == 0) return array;
          int bias, min = array[0], max = array[0];
          for (int i = 1; i < array.length; i++) {
              if (array[i] > max)
                  max = array[i];
              if (array[i] < min)
                  min = array[i];
          }
          bias = 0 - min;
          int[] bucket = new int[max - min + 1];
          Arrays.fill(bucket, 0);
          for (int i = 0; i < array.length; i++) {
              bucket[array[i] + bias]++;
          }
          int index = 0, i = 0;
          while (index < array.length) {
              if (bucket[i] != 0) {
                  array[index] = i - bias;
                  bucket[i]--;
                  index++;
              } else
                  i++;
          }
          return array;
      }
 
 
   算法分析
  
   * 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。
     计数排序不是比较排序，排序的速度快于任何比较排序算法。
     由于用来计数的数组C的长度取决于待排序数组中数据的范围
     （等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围
     很大的数组，需要大量时间和内存。
      * 最佳情况：T(n) = O(n+k)
      * 最差情况：T(n) = O(n+k)
      * 平均情况：T(n) = O(n+k)
 
 
##9、桶排序
 * 桶排序： 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键
   就在于这个映射函数的确定。
 * 桶排序 (Bucket sort)的工作的原理：
   桶排序也称为箱排序，英文称为 Bucket Sort。它是将数组划分到一定数量的有序的桶里，
   然后再对每个桶中的数据进行排序，最后再将各个桶里的数据有序的合并到一起。

 * 算法描述
   * 步骤1：人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；
   * 步骤2：遍历输入数据，并且把数据一个一个放到对应的桶里去；
   * 步骤3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
   * 步骤4：从不是空的桶里把排好序的数据拼接起来。 
   * 注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加
     下一循环桶的数量，否则会陷入死循环，导致内存溢出。
 
   
   
       public static ArrayList<Integer> BucketSort(ArrayList<Integer> array, int bucketSize) {
           // 列表少于两个无需排序
           if (array == null || array.size() < 2)
               return array;
           // 初始化最大、最小值
           int max = array.get(0), min = array.get(0);
           // 找到最大值最小值
           for (int i = 0; i < array.size(); i++) {
               if (array.get(i) > max)
                   max = array.get(i);
               if (array.get(i) < min)
                   min = array.get(i);
           }
           // 计算桶的数量
           int bucketCount = (max - min) / bucketSize + 1;
           // 使用列表作为桶，并创建装桶的列表
           ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketCount);
           // 排序后的返回值
           ArrayList<Integer> resultArr = new ArrayList<>();
           // 根据需要桶的数量创建添加桶
           for (int i = 0; i < bucketCount; i++) {
               bucketArr.add(new ArrayList<Integer>());
           }
           // 根据数据值计算出桶的编号并装入桶中
           for (int i = 0; i < array.size(); i++) {
               bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));
           }
           // 排序各桶
           for (int i = 0; i < bucketCount; i++) {
               if (bucketSize == 1) { // 如果待排序数组中有重复数字时或者桶内的数据个数为1时
                   for (int j = 0; j < bucketArr.get(i).size(); j++)
                       resultArr.add(bucketArr.get(i).get(j));
               } else {
                   if (bucketCount == 1)
                       bucketSize--;
                   // 递归装入桶中,直到桶内的数据个数为1变成计数排序再递归回来
                   ArrayList<Integer> temp = BucketSort(bucketArr.get(i), bucketSize);
         
                   for (int j = 0; j < temp.size(); j++)
                       resultArr.add(temp.get(j));
               }
           }
           return resultArr;
       }
       
       
  算法分析
   
       桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间
   数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，
   各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。
   
  * 最佳情况：T(n) = O(n+k)
  * 最差情况：T(n) = O(n+k)
  * 平均情况：T(n) = O(n2)


##10、基数排序

   * 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，
   复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；

   * 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，
   直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
   最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

* 算法描述
  * 步骤1：取得数组中的最大数，并取得位数；
  * 步骤2：arr为原始数组，从最低位开始取每个位组成radix数组；
  * 步骤3：对radix进行计数排序（利用计数排序适用于小范围数的特点）；
  * 即: 创建0~9的桶,以桶下标为位数的值,存入该位数值为下标的数(例如: 12,5 当进行个位数计数排序时,12存入桶下标为2,5存入桶下标为5,
   当进行十位数计数排序时,12存入桶下标为1的桶,5存入桶下标为0的桶),寻找最大位数然后按照位数进行计数排序,例如: 最大位数是十位,可以先按照个位进行计数排序,也可以先按照十位进行计数排序


        public static int[] RadixSort(int[] array) {
            if (array == null || array.length < 2)
                return array;
            // 1.先算出最大数的位数；
            int max = array[0];
            for (int i = 1; i < array.length; i++) {
                max = Math.max(max, array[i]);
            }
            int maxDigit = 0;
            while (max != 0) {
                max /= 10;
                maxDigit++;
            }
            int mod = 10, div = 1;
            ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();
            // 创建10桶分别装数值为0~9
            for (int i = 0; i < 10; i++)
                bucketList.add(new ArrayList<Integer>());
            for (int i = 0; i < maxDigit; i++, mod *= 10, div *= 10) {
                // 装入桶
                for (int j = 0; j < array.length; j++) {
                    int num = (array[j] % mod) / div;
                    bucketList.get(num).add(array[j]);
                }
                int index = 0;
                // 从桶中取出
                for (int j = 0; j < bucketList.size(); j++) {
                    for (int k = 0; k < bucketList.get(j).size(); k++)
                        array[index++] = bucketList.get(j).get(k);
                    bucketList.get(j).clear();
                }
            }
            return array;
        }


* 算法分析

  * 最佳情况：T(n) = O(n * k)
  * 最差情况：T(n) = O(n * k)
  * 平均情况：T(n) = O(n * k)

* 基数排序有两种方法：

  * MSD 从高位开始进行排序
  * LSD 从低位开始进行排序
  
####基数排序 vs 计数排序 vs 桶排序：

   * 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

      * 基数排序： 根据键值的每位数字来分配桶
      * 计数排序： 每个桶只存储单一键值
      * 桶排序： 每个桶存储一定范围的数值



### 排序的基本知识
* 定义：排序就是将原本无序的序列重新排列成有序的序列。
* 排序的稳定性
    * 如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。
### 插入类排序
* 直接插入排序
    * 直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。
    * 时间复杂度为O(n)
    * 直接插入排序是稳定性是稳定的。
* 折半插入排序
    * 折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。
    * 折半插入排序的时间复杂度为O(n^2)
    * 稳定性：和直接插入排序稳定性相同，是稳定的。
* 希尔排序
    * 希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。
        * ①先以增量5来分割序列，也就是下标为0,5,10,15...的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。
        * ②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。
        * ③接下来的第三轮，第四轮...都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。
        * 概要:  
    * 时间复杂度：...  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)
    * 空间复杂度：希尔排序的空间复杂度为O(1)
    * 稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。
### 交换类排序
* 冒泡排序
    * 假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。
    * 空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)
    * 时间复杂度
    * 稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。
* 快速排序
    * 快速排序是一种基于分治法的排序方法。
每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。
        * 1
        * 2
    * 时间复杂度：
最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。
 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。
    * 空间复杂度：
由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。
最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)
最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；
    * 稳定性：快速排序是不稳定的，是因为存在交换关键字。
### 选择类排序
* 简单选择排序
    *  
    * 空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)
    * 时间复杂度：
关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，
对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。
                      当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)
    * 稳定性：不稳定   原因就在于交换部分会打破相对顺序
* 堆排序
    * 什么是堆？
        * 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。
            * 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。
            * 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。
    * 什么是堆排序？
        * 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。
            *  
            *  
        * 时间复杂度：
       堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆

       堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)
        * 堆排序不稳定
### 归并排序
* 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。
    *   
    *  
* 例如：49 38 65 97 76 13 27
    * ①首先将整个序列的每个关键字看成一个单独的有序的子序列
    * ②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象
    * ③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}
    * ④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}
* 时间复杂度：O(nlog2n)
* 空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)
* 稳定性：稳定
### 基数排序
* 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。
* 例子：53, 3, 542, 748, 14, 214, 154, 63, 616
    * 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616
    * 桶实际是一个队列，先进先出(从桶的上面进，下面出)
    * 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10
* 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)
* 时间复杂度：需要进行关键字位数d次"分配"和"收集"，一次"分配"需要将n个关键字放进各个队列中，一次"收集"需要将r个桶都收集一遍。所以一次"分配"和一次"收集"时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。
* 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。
### 外部排序
* 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。
* 如何得到初始的归并段
    * 置换选择排序：解决排序段放入内存的问题
* 如何减少多个归并段的归并次数
    * 最佳归并树：最少的归并次数（I/O次数）
* 如何每次m路归并快速得到最小的关键字
    * 败者树：减少比较次数
* 概要: 内存容量无法容纳大量数据